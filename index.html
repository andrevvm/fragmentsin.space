<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Fragments in Space</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    
    <style>
      body {
        margin: 0;
        padding: 0; 
        cursor: crosshair;
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
    <script src="js/loaders/BinaryLoader.js"></script>
    <script src="js/Detector.js"></script>
<!--     <script src="js/libs/stats.min.js"></script>
 -->
    <script src="js/Mirror.js"></script>

    <script type="text/javascript" src="js/timbre.js"></script>
    <script type="text/javascript" src="js/timbre_mouse.js"></script>

    <link href="https://fonts.googleapis.com/css?family=Space+Mono" rel="stylesheet">
    <script   src="https://code.jquery.com/jquery-3.1.0.slim.min.js"   integrity="sha256-cRpWjoSOw5KcyIOaZNo4i6fZ9tKPhYYb6i5T9RSVJG8="   crossorigin="anonymous"></script>

    <style>
    .overlay {
      box-sizing: border-box;
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: rgba(0,0,0,0.9);
      padding: 7vmin;
      z-index: 0;
      opacity: 0;
      cursor: default;
      transition: opacity 100ms ease-in-out, z-index 1ms 400ms;
    }

    .overlay.show {
      z-index: 11;
      opacity: 1;
      transition: opacity 400ms ease-in-out, z-index 0ms;
    }

    .overlay.show p {
      opacity: 1;
      transition: opacity 400ms 200ms ease-in-out;
    }

    .overlay p {
      margin-top: 0;
      font-family: "Space Mono", Courier, monospace;
      color: #f6f6f6;
      font-size: 3vmin;
      max-width: 70%;
      opacity: 0;
      transition: opacity 200ms ease-in-out;
    }

    canvas {
      position: relative;
      z-index: 10;
      opacity: 0;
      transition: opacity 500ms ease-in-out;
    }

    label {
      box-sizing: border-box;
      position: absolute;
      z-index: 20;
      top: 4vmin;
      right: 4vmin;
      width: 24px;
      height: 24px;
      border-radius: 12px;
      border: 2px solid #959595;
      cursor: pointer;
    }

    label:hover {
      opacity: 1;
    }

    .fader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ready canvas,
    .loading canvas {
      opacity: 1;
    }
    </style>
    
  </head>

  <body class="loading">
  
    <script type="text/javascript">

    $(function() {
      $("label").click(function() {
        $(".overlay").toggleClass("show");
      });

      $(".overlay").click(function(e) {

        if(e.target.localName === "div") {
          $(this).removeClass("show");
        }
        
      });
    });

    setTimeout(function() {

      // var cutoff = T("sin", {freq:"15000ms", mul:50, add:80}).kr();

      // var VCO = T("tri", {freq:8}).set("mul", 0.4);
      // var VCF = T("lpf", {cutoff:cutoff, Q:30}, VCO);

      // T("reverb", {room:2.0, damp:0.6, mix:0.85}, VCF).play();

      var synth = T("SynthDef").play();

      synth.def = function(opts) {
        var VCO = T("tri", {freq:opts.freq}).set("mul", 0.6);

        var cutoff = T("env", {table:[2000, [opts.freq, 400]]}).bang();
        var VCF    = T("lpf", {cutoff:cutoff, Q:9}, VCO);

        var EG  = T("adsr", {a:90, d:1500, s:0.45, r:500, lv:0.2});
        var VCA = EG.append(VCF).bang();

        return VCA;
      };

      T("reverb", {room:2.0, damp:0.1, mix:0.45}, synth).play();

      var note;

      T("mouse").on("mousedown", function(e) {

          if(e.target.localName === "canvas") {
            note = Math.round(Math.random() * (70 - 50) + 50);
            synth.noteOn(note);
          }
  
      }).on("mouseup", function(e) {

          synth.noteOff(note);

      }).start();

    }, 2000);

    </script>    

    <script type="x-shader/x-vertex" id="sem-vs">

      varying vec2 vN;

      void main() {

        vec3 e = normalize( vec3( modelViewMatrix * vec4( position, .5 ) ) );
        vec3 n = normalize( normalMatrix * normal );

        vec3 r = reflect( e, n );
        float m = 2. * sqrt( pow( r.x, 2. ) + pow( r.y, 2. ) + pow( r.z + 1., 2. ) );
        vN = r.xy / m + .5;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1. );

      }

    </script>

    <script type="x-shader/x-vertex" id="sem-fs">

      uniform sampler2D tMatCap;

      varying vec2 vN;

      void main() {

        vec3 base = texture2D( tMatCap, vN ).rgb;
        gl_FragColor = vec4( base, 1.0 );

      }

    </script>

    <script>

      if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

      var SCREEN_WIDTH = window.innerWidth;
      var SCREEN_HEIGHT = window.innerHeight;

      var SHADOW_MAP_WIDTH = SCREEN_WIDTH, SHADOW_MAP_HEIGHT = SCREEN_HEIGHT;

      var container,stats;

      var onRenderFcts= [];

      var camera, light1, scene, renderer;

      var mouseX = 0, mouseY = 0;

      var NEAR = 1, FAR = 25000;

      var blockMirror, groundMirror;

      var time = 0;
      var mag = 0;

      var lastTimeMsec= null;
      var nowMsec = null;

      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;

      var loadMeshes, loadMesh, egh;

      init();
      animate();


      function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        renderer = new THREE.WebGLRenderer( { antialias: true } );

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowMap;
        //renderer.shadowMap.renderReverseSided = false;

        //

        camera = new THREE.PerspectiveCamera( 35, SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR );
        camera.position.z = 2000;
        camera.position.y = 1000;

        mirrorCubeCamera = new THREE.CubeCamera( 10, 10000, 5 );
        
        scene = new THREE.Scene();

        scene.add( mirrorCubeCamera );

        var fogs = [
          0xBDE3F4,
          0x1A1F21,
          0xf2eedd
        ]

        scene.fog = new THREE.Fog( 0xFFFFFF, 1, 25000 );

        //scene.add( new THREE.AmbientLight( 0xffffff ) );

        light1 = new THREE.SpotLight( 0xffffff, 0.3, 0, Math.PI / 2 );
        light1.position.set( 2000, 4000, -3000 );
        light1.target.position.set( 1, 1, 1 );

        //light1.position.set( 1, 1, 1 );
        light1.castShadow = true;

        light1.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 20, 10, 100, 20000 ) );
        light1.shadow.bias = 0.0001;
        light1.shadow.camera.near = NEAR;
        light1.shadow.camera.far = FAR;
        light1.shadow.camera.fov = 15;

        light1.shadow.mapSize.width = SHADOW_MAP_WIDTH;
        light1.shadow.mapSize.height = SHADOW_MAP_HEIGHT;

        light1.shadow.camera.right    =  50000;
        light1.shadow.camera.left     = -50000;
        light1.shadow.camera.top      =  50000;
        light1.shadow.camera.bottom   = -50000;
      
        //scene.add( light1 );

        hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.8 );
        //hemiLight.color.setHSL( 0.6, 1, 0.6 );
        //hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
        hemiLight.position.set( 100, 500, 0 );
        scene.add( hemiLight );

        //

        dirLight = new THREE.DirectionalLight( 0xffffff, 0.4 );
        //dirLight.color.setHSL( 0.1, 1, 0.95 );
        dirLight.position.set( -3000, 4000, 3000 );
        //dirLight.position.multiplyScalar( 50 );
        scene.add( dirLight );

        dirLight.castShadow = true;

        dirLight.shadow.mapSize.width = 3048;
        dirLight.shadow.mapSize.height = 3048;

        var d = 1500;

        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.camera.near = 40;
        dirLight.shadow.camera.far = 10000;
        dirLight.shadow.bias = 0.00001;
        dirLight.shadow.darkness = 0.2;

        var textureLoader = new THREE.TextureLoader();

        var objectTextures = [
          
          textureLoader.load("textures/dark_green_marble.jpg", loadEnqueue),
          textureLoader.load("textures/green_granite.jpg", loadEnqueue),
          textureLoader.load("textures/red_marble.jpg", loadEnqueue),
          textureLoader.load("textures/travertine.jpg", loadEnqueue)

        ];

        var customShapeTextures = [
          textureLoader.load("textures/dark_green_marble.jpg",loadEnqueue),
          textureLoader.load("textures/green_granite.jpg",loadEnqueue),
          textureLoader.load("textures/red_marble.jpg",loadEnqueue),
          textureLoader.load("textures/travertine.jpg",loadEnqueue)
        ];

        var loaded = 0;

        scenePreload();

        var loadQueue = [];
        function loadEnqueue() {
          loadQueue.push(textureLoaded);
        }

        setInterval(function() {
          if(loadQueue.length > 0) {
            (loadQueue.shift())();
          }
        }, 100);

        function textureLoaded() {
          loaded++;

          if(loaded === 8) {
            $('body').removeClass('loading');
            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );
            document.addEventListener( 'touchend', onDocumentMouseDown, false );
            document.addEventListener( 'wheel', onDocumentWheel, false );
            
            setTimeout(function() {
              sceneInit(comp);
            }, 400);

            setTimeout(function() {
              $('body').addClass('ready');
            }, 600);

            return false;
          }

          //egh.geometry = null;
          //egh.geometry = loadMeshes[loaded].geometry;

          scene.remove(egh);

          egh = new THREE.EdgesHelper( loadMeshes[loaded], fogs[1] );
          egh.matrixAutoUpdate = true;
          egh.rotation.y = Math.PI / 4;
          //egh.rotation.x = Math.PI / (2 * loaded);
          egh.material.linewidth = 2;

          scene.add(egh);
  
        }
        

        for(var b = 0; b < objectTextures.length; b++) {
          objectTextures[b].anisotropy = 5;
          objectTextures[b].wrapS = objectTextures[b].wrapT = THREE.MirroredRepeatWrapping;
          objectTextures[b].repeat.set( 1, 1 );
        }

        for(var b = 0; b < customShapeTextures.length; b++) {
          customShapeTextures[b].anisotropy = 5;
          customShapeTextures[b].wrapS = objectTextures[b].wrapT = THREE.MirroredRepeatWrapping;
          customShapeTextures[b].repeat.set( 1 / 1200, 1 / 1200 );
          customShapeTextures[b].offset.set( 0.1, 0.1 );
        }

        var path = "textures/skybox/";
        var format = '.jpg';
        var urls = [
            path + 'px' + format, path + 'nx' + format,
            path + 'py' + format, path + 'ny' + format,
            path + 'pz' + format, path + 'nz' + format
          ];

        var refractionCube = new THREE.CubeTextureLoader().load( urls );
        refractionCube.mapping = THREE.SphericalReflectionMapping;
        refractionCube.format = THREE.RGBFormat;

        var iridescent = new THREE.ShaderMaterial( {

          uniforms: { 
            tMatCap: {type: 't', value: objectTextures[0] },
          },
          
          vertexShader: document.getElementById( 'sem-vs' ).textContent,
          fragmentShader: document.getElementById( 'sem-fs' ).textContent,
          shading: THREE.SmoothShading
          
        } );

        // var goldMaterial = new THREE.MeshStandardMaterial( { 
        //   color: 0xFFC59F, 
        //   map: objectTextures[0],
        //   roughness: 0.6, 
        //   metalness: 0.5,
        //   envMap: refractionCube 
        // } );

        var glassMaterial = new THREE.MeshPhongMaterial( { 
            color: 0x57BBA3,
            emissive: 0x000000,
            specular: 0xFFFFFF,
            envMap: mirrorCubeCamera.renderTarget.texture,
            refractionRatio: 0.11,
            combine: THREE.MixOperation, 
            reflectivity: 0.1,
            shininess: 40,
            transparent: true,
            opacity: 0.9
          } )

        var objectMaterials = [
          new THREE.MeshPhongMaterial( { color: 0xffffff, map: objectTextures[0] } ),
          new THREE.MeshPhongMaterial( { color: 0xffffff, map: objectTextures[1] } ),
          new THREE.MeshPhongMaterial( { color: 0xffffff, map: objectTextures[2] } ),
          new THREE.MeshPhongMaterial( { color: 0xffffff, map: objectTextures[3] } ),
          new THREE.MeshPhongMaterial( { color: 0xEB6584 } ),
          new THREE.MeshPhongMaterial( { color: 0xE6543B } ),
        ];

        var customShapeMaterials = [
          new THREE.MeshPhongMaterial( { color: 0xffffff, map: customShapeTextures[0] } ),
          new THREE.MeshPhongMaterial( { color: 0xffffff, map: customShapeTextures[1] } ),
          new THREE.MeshPhongMaterial( { color: 0xffffff, map: customShapeTextures[2] } ),
          new THREE.MeshPhongMaterial( { color: 0xffffff, map: customShapeTextures[3] } ),
          new THREE.MeshPhongMaterial( { color: 0xEB6584 } ),
          new THREE.MeshPhongMaterial( { color: 0xE6543B } ),
        ];

        var blockMaterials = [
          objectMaterials[0],
          objectMaterials[1],
          objectMaterials[2],
          objectMaterials[3],
          objectMaterials[4],
          objectMaterials[5],
        ]

        shuffle(blockMaterials);
        shuffle(objectMaterials);
        shuffle(customShapeMaterials);

        groundMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.3, textureWidth: 2048, textureHeight: 2048, color: 0x81A0BD } );

        blockMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.3, textureWidth: 2048, textureHeight: 2048, color: 0x414042 } );

        var groundMaterials = [
          new THREE.MeshPhongMaterial( { color: 0xffffff, map: objectTextures[0] } ),
          new THREE.MeshPhongMaterial( { color: 0xffffff, map: objectTextures[1] } ),
          new THREE.MeshPhongMaterial( { color: 0xffffff, map: objectTextures[2] } ),
          new THREE.MeshPhongMaterial( { color: 0xffffff, map: objectTextures[3] } ),
          groundMirror.material
        ]

        shuffle(groundMaterials);

        // texture1.anisotropy = 5;
        // texture1.wrapS = texture1.wrapT = THREE.MirroredRepeatWrapping;
        // texture1.repeat.set( 1, 1 );

        // texture2.anisotropy = 5;
        // texture2.wrapS = texture2.wrapT = THREE.MirroredRepeatWrapping;
        // texture2.repeat.set( 1, 1 );

        // texture3.anisotropy = 5;
        // texture2.wrapS = texture2.wrapT = THREE.MirroredRepeatWrapping;
        // texture3.repeat.set( 1, 1 );

        // texture4.anisotropy = 5;
        // texture2.wrapS = texture2.wrapT = THREE.MirroredRepeatWrapping;
        // texture4.repeat.set( 1, 1 );

        var ground = new THREE.BoxGeometry( 1000, 1000, 25 );

        var meshGround = new THREE.Mesh( ground, groundMaterials[0] );

        meshGround.position.set(0,-200,0);

        meshGround.rotation.x = - Math.PI / 2;
        meshGround.rotation.z = - Math.PI / 4;
        meshGround.receiveShadow = true;

        meshGround.add( groundMirror );

        var boxShapes =  [
          new THREE.BoxGeometry( 800, 450, 80 ),
          //new THREE.CylinderGeometry( 0, 220, 360, 4 )
        ]

        shuffle(boxShapes);

        var scenes = [
            {
              objects: {
                block: {
                  mesh: new THREE.Mesh( new THREE.BoxGeometry( 900, 450, 50 ) ),
                  type: "block"
                },
                block2: {
                  mesh: new THREE.Mesh( new THREE.BoxGeometry( 600, 450, 50 ) ),
                  type: "block"
                },
                cylinder: {
                  mesh: new THREE.Mesh( new THREE.CylinderGeometry(8, 8, 500, 50) ),
                  type: "object"
                },
                sphere: {          
                  mesh: new THREE.Mesh( new THREE.SphereGeometry( 70, 40, 40 ) ),
                  type: "object"
                },
                
              },
              customShape: function() {
                var brokeShape = new THREE.Shape();
                brokeShape.moveTo( 0, 0 );
                brokeShape.lineTo( 0, 500 );
                brokeShape.lineTo( -600, 500);
                brokeShape.lineTo( -600, 600);
                brokeShape.lineTo( 300, 600);
                brokeShape.lineTo( 300, 0);

                var extrudeSettings = { amount: 70, bevelEnabled: false, material: 0, extrudeMaterial: 0 };

                var geometry = new THREE.ExtrudeGeometry( brokeShape, extrudeSettings );

                var mesh = new THREE.Mesh( geometry );

                return mesh;
              },
              setPositions: function() {

                if(this.rendered === true) {
                  return false;
                }

                this.objects.block.mesh.rotation.y = (Math.PI / 4);
                this.objects.block.mesh.position.set(300,-300,-100);

                this.objects.block2.mesh.rotation.y = -(Math.PI / 4);
                this.objects.block2.mesh.position.set(-200,-25,150);

                this.objects.cylinder.mesh.geometry.translate(0,0,0);
                this.objects.cylinder.mesh.position.set(-200, 240, 550);
                //this.objects.cylinder.mesh.rotation.x = Math.PI;
                //this.objects.cylinder.mesh.rotateZ(-5);
                this.objects.cylinder.mesh.rotateY(-0.9);
                this.objects.cylinder.mesh.rotateZ(-0.2);

                this.objects.sphere.mesh.geometry.translate(-40, 230, 0);
                this.objects.sphere.mesh.rotation.y = 2.5;
                this.objects.sphere.mesh.rotation.x = 0.4;
                this.objects.sphere.mesh.position.set(170,250,150);
                

                this.rendered = true;
              },
              setMaterials: function() {

                this.objects.block.mesh.geometry = null;
                this.objects.block.mesh.geometry = this.customShape().geometry;         
                this.objects.block.mesh.material = customShapeMaterials[0];
                this.objects.block.mesh.material.needsUpdate = true;
             
                this.objects.block2.mesh.material = blockMaterials[0];

                meshGround.material = groundMaterials[0];
                this.objects.cylinder.mesh.material = objectMaterials[1];

                this.objects.sphere.mesh.material = objectMaterials[0];
                

                for(var key in this.objects) {
                  this.objects[key].mesh.castShadow = true;
                  this.objects[key].mesh.receiveShadow = true;
                }

                
              },
              postInit: function() {
                

              },
              animations: function() {

                this.objects.cylinder.mesh.rotation.y += 0.01;
                this.objects.cylinder.mesh.position.y = 180 + Math.sin(time/1000) * 20;

                //this.objects.sphere.mesh.rotation.y += 0.01;
                this.objects.sphere.mesh.rotation.y += 0.005;
                this.objects.sphere.mesh.rotation.x += 0.01;
                

              },

              sceneCleanup: function() {

              },
              rendered: false

            },
            {
              objects: {
                block: {
                  mesh: new THREE.Mesh( new THREE.BoxGeometry( 900, 450, 50 ) ),
                  type: "block"
                },
                block2: {
                  mesh: new THREE.Mesh( new THREE.BoxGeometry( 80, 500, 280 ) ),
                  type: "block"
                },
                block3: {
                  mesh: new THREE.Mesh( new THREE.BoxGeometry( 160, 600, 160 ) ),
                  type: "block"
                },
                block4: {
                  mesh: new THREE.Mesh( new THREE.BoxGeometry( 600, 450, 50 ) ),
                  type: "block"
                },
                sphere: {          
                  mesh: new THREE.Mesh( new THREE.SphereGeometry( 70, 40, 40 ) ),
                  type: "object"
                },
                
              },
              setPositions: function() {

                if(this.rendered === true) {
                  return false;
                }

                this.objects.sphere.mesh.geometry.translate(150,150,180);
                this.objects.sphere.mesh.rotation.z = 250;
                this.objects.sphere.mesh.position.set(0,150,-200);
                
                this.objects.block.mesh.rotation.y = - (Math.PI / 4) * 3;
                this.objects.block.mesh.position.set(350,-20,-50);

                this.objects.block2.mesh.rotation.y = (Math.PI / 4);
                this.objects.block2.mesh.position.set(-50,60,350);

                this.objects.block3.mesh.rotation.y = (Math.PI / 4);
                this.objects.block3.mesh.position.set(0,200,-300);

                this.objects.block4.mesh.rotation.y = -(Math.PI / 4);
                this.objects.block4.mesh.position.set(-300,100,-200);

                this.rendered = true;
              },
              setMaterials: function() {
             
                this.objects.block.mesh.material = objectMaterials[0];
                this.objects.block2.mesh.material = blockMaterials[1];
                this.objects.block3.mesh.material = blockMaterials[2];
                this.objects.block4.mesh.material = blockMaterials[0];
                this.objects.sphere.mesh.material = objectMaterials[1];

                for(var key in this.objects) {
                  this.objects[key].mesh.castShadow = true;
                  this.objects[key].mesh.receiveShadow = true;
                }

                
              },
              postInit: function() {
                

              },
              animations: function() {

                this.objects.block3.mesh.position.y = 250 + Math.sin(time/500) * 20;
                this.objects.block4.mesh.position.y = 150 + Math.sin(time/500 - 580) * 20;

                this.objects.sphere.mesh.position.y = 460 - Math.sin(time/1000) * 150;
                this.objects.sphere.mesh.rotation.y += 0.01;
                //this.objects.sphere.mesh.rotation.z = 20;

              },

              sceneCleanup: function() {

              },
              rendered: false

            },
            {
              objects: {

                block1: {
                  mesh: new THREE.Mesh( new THREE.BoxGeometry( 380, 550, 30 ) ),
                  type: "block"
                },

                block2: {
                  mesh: new THREE.Mesh( new THREE.BoxGeometry( 300, 300, 30 ) ),
                  type: "block"
                },

                cone1: {
                  mesh: new THREE.Mesh( new THREE.CylinderGeometry( 0, 160, 420, 50 ) ),
                  type: "object"
                },

                // sphere1: {
                //   mesh: new THREE.Mesh( new THREE.SphereGeometry(120, 40, 40 ) ),
                //   type: "object"
                // }

                
                
              },
              setPositions: function() {
                if(this.rendered === true) {
                  return false;
                }
                this.objects.block1.mesh.position.set(-50, 100, -250);
                this.objects.block1.mesh.rotateX(-0.15);
                this.objects.block1.mesh.rotateZ(0.55);
                this.objects.block1.mesh.rotation.y = - 3.5;

                this.objects.block2.mesh.position.set(500, -130, 130);
                this.objects.block2.mesh.rotation.z = -2.5;
                this.objects.block2.mesh.rotation.x = 0.3;

                this.objects.cone1.mesh.position.set(-250, 20, 180);
                // this.objects.cone1.mesh.rotation.x = Math.PI / 2;
                // this.objects.cone1.mesh.rotation.y = Math.PI / 2;
                this.objects.cone1.mesh.rotateZ(-2.25);
                //this.objects.cone1.mesh.rotation.y = 0.45;

                // this.objects.sphere1.mesh.geometry.translate(-120,0,150);
                // this.objects.sphere1.mesh.posfition.set(0,0,150);
                
                this.rendered = true;
              },
              setMaterials: function() {
                             
                this.objects.block1.mesh.material = blockMirror.material;
                this.objects.block1.mesh.add(blockMirror);

                this.objects.block2.mesh.material = blockMaterials[0];
                
                this.objects.cone1.mesh.material = objectMaterials[1];

                for(var key in this.objects) {
                  this.objects[key].mesh.castShadow = true;
                  this.objects[key].mesh.receiveShadow = true;
                }
              },
              postInit: function() {

              },
              animations: function() {

                this.objects.block1.mesh.position.y = 220 + Math.sin(time/500 - 580) * 20;
                this.objects.cone1.mesh.rotation.x += 0.01;
                this.objects.cone1.mesh.position.y = 250 + Math.sin(time/500 - 240) * 20;

              },
              sceneCleanup: function() {

              },
              rendered: false

            },
        ];

        shuffle(scenes);
        var comp = scenes[0];

        // RENDERER

        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

        renderer.autoClear = true;

        renderer.domElement.style.position = "relative";
        container.appendChild( renderer.domElement );

        //Mesh animations
        onRenderFcts.push(function(){

          time += 10;
  
          for(var i = 0; i < scenes.length; i++) {
            scenes[i].animations();
            for(var key in scenes[i].objects) {
              if(scenes[i].objects[key].type === "object") {
                scenes[i].objects[key].mesh.rotation.y += mag;
              }
            }
          }
          
        });

        // STATS1

        // stats = new Stats();
        // container.appendChild( stats.dom );

        for(var i = 0; i < scenes.length; i++) {
          addObjects(scenes[i]);
          scenes[i].setPositions();
          hideObjects(scenes[i]);
        }

        function scenePreload() {

          loadMeshes = [
            new THREE.Mesh( new THREE.BoxGeometry( 120, 120, 60 ) ),
            new THREE.Mesh( new THREE.SphereGeometry( 80, 8, 8 ) ),
            new THREE.Mesh( new THREE.ConeGeometry( 80, 140, 8 ) ),
            new THREE.Mesh( new THREE.CylinderGeometry( 80, 80, 120, 8 ) ),
            new THREE.Mesh( new THREE.BoxGeometry( 120, 60, 120 ) ),
            new THREE.Mesh( new THREE.CylinderGeometry( 80, 0, 120, 8 ) ),
            new THREE.Mesh( new THREE.BoxGeometry( 120, 120, 120 ) ),
            new THREE.Mesh( new THREE.ConeGeometry( 80, 140, 8 ) ), 
          ]
          shuffle(loadMeshes);
          loadMesh = loadMeshes[0];

          shuffle(fogs);

          egh = new THREE.EdgesHelper( loadMesh, fogs[1] );
          egh.matrixAutoUpdate = true;
          egh.rotation.y = Math.PI / 4;
          egh.material.linewidth = 2;
          scene.add( egh );

          renderer.setClearColor( fogs[0] );

          var r = (fogs[0] & (0xff << 16)) >>> 16;
          var g = (fogs[0] & (0xff << 8)) >>> 8;
          var b = (fogs[0] & 0xff);

          console.log(r,g,b);

          $('body').css('background','rgba('+r+','+g+','+b+',1)');

        }

        function sceneInit(s) {
          scene.remove(loadMesh);
          scene.remove(egh);
          scene.add( meshGround );
          setMaterials(s);
          showObjects(s);
        }

        function addObjects(s) {
          for(var key in s.objects) {
            scene.add(s.objects[key].mesh);
          }
        }

        function showObjects(s) {
          for(var key in s.objects) {
            s.objects[key].mesh.visible = true;
          }
          s.postInit();
        }

        function hideObjects(s) {
          for(var key in s.objects) {
            s.objects[key].mesh.visible = false;
          }
        }

        function setMaterials(s) {
          shuffle(objectMaterials);
          shuffle(blockMaterials);
          shuffle(groundMaterials);
          
          shuffle(boxShapes);

          for(var key in s.objects) {
            if(s.objects[key].type === "object") {
              s.objects[key].mesh.add(blockMirror);
            }
          }

          s.setMaterials();
          
        }

        function onDocumentMouseDown(event) {

          if(event.target.localName === "canvas") {
            shuffle(fogs);
            renderer.setClearColor( fogs[0] );

            hideObjects(comp);
            comp.sceneCleanup();
            shuffle(scenes);
            comp = scenes[0];
            sceneInit(comp);
          }

        }

      }


      function onDocumentMouseMove(event) {

        mouseX = ( event.clientX - windowHalfX );
        mouseY = ( event.clientY - windowHalfY );

      }

      function onDocumentWheel(event) {
        event.preventDefault();
        //mag = event.deltaY * 0.0008;
      }

      function animate() {


        requestAnimationFrame( animate );

        render();
        //stats.update();

      }

      function render() {

        camera.position.x += ( mouseX - camera.position.x ) * .05;
        camera.position.y = THREE.Math.clamp( camera.position.y + ( - ( mouseY - 600 ) - camera.position.y ) * .05, 50, 1000 );
        dirLight.position.x += ( mouseX - dirLight.position.x - 1000 ) * .05;

        camera.lookAt( scene.position );

        renderer.clear();
        //renderer.setScissorTest( true );

        //renderer.setScissor( 0, 0, SCREEN_WIDTH/2 - 2, SCREEN_HEIGHT );

        mirrorCubeCamera.updateCubeMap( renderer, scene );

        groundMirror.render();
        blockMirror.render();

        renderer.render( scene, camera );

        //renderer.setScissor( SCREEN_WIDTH/2, 0, SCREEN_WIDTH/2 - 2, SCREEN_HEIGHT  );

        //renderer.setScissorTest( false );

        // measure time
        lastTimeMsec  = lastTimeMsec || nowMsec-1000/60
        var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
        lastTimeMsec  = nowMsec
        // call each update function
        onRenderFcts.forEach(function(onRenderFct){
          onRenderFct(deltaMsec/1000, nowMsec/1000);
        });


      }

      function shuffle(array) {
        var currentIndex = array.length, temporaryValue, randomIndex;

        // While there remain elements to shuffle...
        while (0 !== currentIndex) {

          // Pick a remaining element...
          randomIndex = Math.floor(Math.random() * currentIndex);
          currentIndex -= 1;

          // And swap it with the current element.
          temporaryValue = array[currentIndex];
          array[currentIndex] = array[randomIndex];
          array[randomIndex] = temporaryValue;
        }

        return array;
      }

    </script>

    <label class="info-label"></label>

    <div class="overlay">
      <p>Fragments in Space is a digital exploration of modernist era design, inspired by the work of Luis Barragán, Ludwig Mies van der Rohe, Laszlo Maholy-Nagy and El Lissitzky. By interchanging elements from each work such as material, form and color, an infinite variety of possibilities arise resulting in contemporary interpretations of the original archive.
      </p>
      <p>
      Concept and art direction by Kara Zichittella.<br/>Code and sound design by Andrew McCarthy.
      </p>
    </div>

    <div class="fader">

    </div>

  </body>
</html>
